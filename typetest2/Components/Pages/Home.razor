@page "/"
@rendermode InteractiveServer

@using Microsoft.AspNetCore.Components.Web
@using MudBlazor

<big>Try typing the sentence below as fast as you can!</big>

<p>
    @for (int i = 0; i < CorrectSentence.Length; i++)
    {
        char c = CorrectSentence[i];
        string style = i < UserInput.Length
            ? (UserInput[i] == c ? "color:green;" : "color:red;")
            : "color:gray;";
        <span style="@style">@c</span>
    }
</p>

<MudProgressLinear Value="@ProgressPercent" Color="Color.Primary" Style="margin-bottom:10px;" />

<MudInput T="string"
          Value="@UserInput"
          ValueChanged="@OnInputChanged"
          Immediate="true"
          Variant="Variant.Outlined"
          Disabled="@IsCompleted"
          Placeholder="Start typing here..."
          aria-label="Typing input" />

@if (IsCompleted)
{
    @if (ElapsedTime.HasValue)
    {
        <p>Time taken: @ElapsedTime.Value.TotalSeconds.ToString("F2") seconds</p>
        <p>Words Per Minute: @((GetWordCount() / (ElapsedTime.Value.TotalSeconds / 60)).ToString("F1"))</p>
    }
    else
    {
        <p>Calculating time...</p>
    }
    <p>Mistakes: @mistakes</p>

    <p><b>Improvement:</b> @ImprovementMessage</p>
    <p><b>Common error positions:</b> @CommonErrorPositions</p>

    <MudButton OnClick="ResetTest" Variant="Variant.Filled" Color="Color.Secondary" Class="mt-3">Try Again</MudButton>
}
else
{
    <p>@ResultMessage</p>
    <MudButton OnClick="ResetTest" Variant="Variant.Outlined" Color="Color.Secondary">Restart</MudButton>
}

@code {
    private const string CorrectSentence = "the quick brown fox jumps over the lazy dog";
    private string UserInput = string.Empty;

    private DateTime? StartTime;
    private TimeSpan? ElapsedTime;
    private int mistakes = 0;

    private string ResultMessage => UserInput == CorrectSentence ? "✅ Matched!" : "❌ Keep Typing...";
    private bool IsCompleted => UserInput == CorrectSentence;

    private double ProgressPercent =>
        100.0 * Math.Min(UserInput.Length, CorrectSentence.Length) / CorrectSentence.Length;

    private int GetWordCount() =>
        CorrectSentence.Split(' ', StringSplitOptions.RemoveEmptyEntries).Length;

    // Store previous results simply
    private TimeSpan? PreviousTime;
    private int? PreviousMistakes;

    // Error position counts
    private Dictionary<int, int> ErrorCounts = new();

    private string ImprovementMessage = "No previous data.";
    private string CommonErrorPositions = "No errors yet.";

    private async Task OnInputChanged(string newValue)
    {
        if (StartTime == null && !string.IsNullOrEmpty(newValue))
        {
            StartTime = DateTime.Now;
            ElapsedTime = null;
            mistakes = 0;
        }

        if (newValue.Length > CorrectSentence.Length)
            newValue = newValue[..CorrectSentence.Length];

        int oldLength = UserInput.Length;
        if (newValue.Length > oldLength)
        {
            int i = oldLength;
            if (i < CorrectSentence.Length && newValue[i] != CorrectSentence[i])
            {
                mistakes++;
            }
        }

        UserInput = newValue;

        if (IsCompleted && StartTime != null && !ElapsedTime.HasValue)
        {
            ElapsedTime = DateTime.Now - StartTime.Value;

            // Analyze improvement compared to last
            AnalyzeImprovement();

            // Record error positions for this round
            RecordErrorPositions();

            await InvokeAsync(StateHasChanged);
        }
    }

    private void AnalyzeImprovement()
    {
        if (PreviousTime == null || PreviousMistakes == null)
        {
            ImprovementMessage = "First attempt recorded.";
        }
        else
        {
            bool faster = ElapsedTime < PreviousTime;
            bool fewerMistakes = mistakes < PreviousMistakes;

            if (faster && fewerMistakes)
                ImprovementMessage = "Great! Faster and fewer mistakes.";
            else if (faster)
                ImprovementMessage = "Faster but watch mistakes.";
            else if (fewerMistakes)
                ImprovementMessage = "Fewer mistakes but try to speed up.";
            else
                ImprovementMessage = "No improvement detected yet.";
        }

        PreviousTime = ElapsedTime;
        PreviousMistakes = mistakes;
    }

    private void RecordErrorPositions()
    {
        for (int i = 0; i < UserInput.Length; i++)
        {
            if (UserInput[i] != CorrectSentence[i])
            {
                if (ErrorCounts.ContainsKey(i))
                    ErrorCounts[i]++;
                else
                    ErrorCounts[i] = 1;
            }
        }

        if (ErrorCounts.Count == 0)
        {
            CommonErrorPositions = "No errors yet.";
        }
        else
        {
            var topErrors = ErrorCounts
                .OrderByDescending(kv => kv.Value)
                .Take(3)
                .Select(kv => $"{kv.Key} ('{CorrectSentence[kv.Key]}'): {kv.Value} times");

            CommonErrorPositions = string.Join(", ", topErrors);
        }
    }

    private void ResetTest()
    {
        UserInput = string.Empty;
        StartTime = null;
        ElapsedTime = null;
        mistakes = 0;
        ImprovementMessage = PreviousTime == null ? "No previous data." : ImprovementMessage;
        // We keep PreviousTime, PreviousMistakes, and ErrorCounts across rounds for ongoing analysis
    }
}
